
[{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/","section":"Eclipse","summary":"","title":"Eclipse","type":"page"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/tags/eisenstein/","section":"Tags","summary":"","title":"Eisenstein","type":"tags"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/tags/%E5%A4%9A%E9%A1%B9%E5%BC%8F/","section":"Tags","summary":"","title":"多项式","type":"tags"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/categories/%E9%AB%98%E7%AD%89%E4%BB%A3%E6%95%B0/","section":"Categories","summary":"","title":"高等代数","type":"categories"},{"content":"\r第一次学习高代的时候, 书上有一个 Eisenstein 判别法, 用来判别多项式在 \\( \\mathbb{Q} \\) 上是否可约. 定理的条件是这样的\n定理 1.1\r(Eisenstein 判别法)\r对整系数多项式 \\( p(x) = a_n x^n + a_{n - 1} x^{n - 1} + \\cdots + a_0 \\), 若存在素数 \\( m \\in \\mathbb{Z} \\), 满足\n\\( m \\nmid a_n \\); \\( m \\mid a_{n - 1}, \\cdots, a_0 \\); \\( m^2 \\nmid a_{0} \\) 则 \\( p(x) \\) 在有理数域上不可约. 初学这个定理, 完全不理解定理是什么意思. 还有一个问题是, 判别法中的素数应该怎么选取, 有时为了使用定理还需要做变量替换, 这个替换应该怎么找. 因为后来也一直没用过这个定理, 所以也没有去思考过. 直到我做高等代数的助教, 自觉不得不研究一下定理的含义(也是为了丰富习题课内容), 特别还需要讲清楚怎么使用定理. 后来在网上看到了一些很好的解释, 找了点论文, 终于理解了定理, 以及如何找素数.\n理念 #\r简单来说, Eisenstein 判别法可以总结为一句话:\n在 \\(\\mathbb{Z}_m \\) 上看, 单项式的分解只能是两个单项式的乘积.\n前半句是说要把多项式放在模 \\( m \\) 域上看. 在 Eisenstein 判别法的条件下, 由于除了最高次项的系数都能被 \\( m \\) 整除, 所以放在 \\( \\mathbb{Z}_m \\) 上时, 多项式只剩下最高项, 即 $$ p(x) \\equiv [a_n]x^n \\mathrm{\\ mod\\ } m, $$ 而后半句是说, 单项式只能分解为两个单项式的乘积. 这是因为 \\( \\mathbb{Z}_m \\) 是域, 没有零因子, 所以如果有 \\( a(x), b(x) \\in \\mathbb{Z}_m[x] \\), \\( p(x) = a(x)b(x) \\), 并且 \\( a(x) \\) 不是单项式, 那么 \\( a(x) \\) 最低次项和 \\( b(x) \\) 最低次项的乘积一定不为 \\( 0 \\), 且不会被其他项消掉. 因此其乘积不可能是单项式.\n这说明了为什么 Eisenstein 判别法中必须用素数. 如果是合数, 那么单项式有可能可以分解为两个非单项式的乘积, 例如在 \\( \\mathbb{Z}_4 \\) 上, \\( x^4 = (x^2 + 2)(x^2 - 2) \\).\n也就是说, 因为在域上的单项式只能被分解为两个单项式的乘积, 所以如果某个多项式 \\( p(x) \\) 放在 \\( \\mathbb{Z}_m \\) 上是单项式, 那么它只要在有理数域(因为这里是整系数多项式, 所以等于是整数环)上可约, 那么分解后的两个多项式在 \\( \\mathbb{Z}_m \\) 上必须也是单项式. 因此两个因式的常数项必须被 \\( m \\) 整除. 那么 \\( p(x) \\) 的常数项作为两个因式常数项的乘积, 自然可以被 \\( m^2 \\) 整除. 这是可约的推论, 也就是一个必要条件. 所以只要不满足这个条件, 原来多项式一定不可约.\n最后再次总结一下, 三个条件的意义分别是:\n(1. + 2.) \\( m \\nmid a_n \\), \\( m \\mid a_{n - 1}, \\cdots, a_0 \\): 多项式在 \\( \\mathbb{Z}_m \\) 上首项非零, 其余项皆为零, 即为单项式; \\( m^2 \\nmid a_{0} \\): 多项式的常数项不能拆成两个 \\( m \\) 之倍数的乘积, 所以不能在有理数域可约. 寻找素数 \\( m \\) #\r这里主要从做题的角度考虑. 如果题目里要判断一个整系数多项式是否可约, 那基本上就等于告诉我们: 这个多项式不可约, 请用 Eisenstein 判别法. 所以我们只需要找一个合适的 \\( m \\). 同时一般来说题目给出的多项式不能一眼看出素数, 还需要做一次变量代换(一般是 \\( x \\rightarrow y \\pm 1 \\)).\n第一种方法是直接利用定理的条件, 例如 \\( p(x) = x^4 + x^3 + x^2 + 6x + 1 \\). 设代换为 \\( x \\rightarrow y + a \\), 那么展开后得到 $$\rp(x) = q(y) = x^4 + (4a + 1)x^3 + (9a + 1)x^2 + (9a + 6)x + (9a + 1),\r$$ 那么如果存在 \\( m \\), 应该有同余方程 $$\r\\begin{aligned}\r4a + 1 \\equiv{}\u0026 0 (\\mathrm{mod\\ } m) \\\\\r9a + 1 \\equiv{}\u0026 0 (\\mathrm{mod\\ } m) \\\\\r9a + 6 \\equiv{}\u0026 0 (\\mathrm{mod\\ } m) \\\\\r9a + 1 \\not\\equiv{}\u0026 0 (\\mathrm{mod\\ } m^2) \\\\\r\\end{aligned}\r$$ 由第二、第三个方程可以得到 \\( 5 \\equiv 0 (\\mathrm{mod } m) \\), 所以 \\( m = 5, a = 1 \\). 因此这个多项式在有理数域不可约.\n另一种方法是直接确定几个可能的素数, 再去尝试. 方法是计算多项式的判别式. 因为 Eisenstein 判别法中的素数 \\( m \\) 需要让多项式变成一个单项式(哪怕是需要做变量替换才能变成 \\( a_nx^n \\) 形的, 其实也是单项式, 只不过是 \\( a_n(x + t)^n \\) 这样), 所以在 \\( \\mathrm{Z}_m \\) 上多项式一定是有重根的, 因此其判别式一定为 \\( 0 \\). 而这个判别式为 \\( 0 \\) 是在 \\( \\mathrm{Z}_m \\) 上, 所以等价于说 \\( p(x) \\) 在 \\( \\mathbb{Q} \\) 上的判别式能被 \\( m \\) 整除. 因此可行的素数一定是 \\( p(x) \\) 判别式的因子.\n例如 \\( p(x) = x^6 + x^3 + 1 \\). 这是一个很好的用判别式来确定素数的例子, 因为一般来说判别式要用结式来计算, 很麻烦, 但是这个很好计算. 这里可以用根来计算. 我们知道判别式可以用结式来计算, 判别式和「多项式和其导数的结式」只相差一些符号和首项的次方, 但是在这里首项为 \\( 1 \\), 所以不影响. 而如果知道其中一个多项式的根, 可以代入另一个多项式来计算结式. 记 \\( q(x) = p^\\prime(x) = 6x^5 + 3x^2 \\), 那么容易看出 \\( q(x) \\) 的五个根分别是 \\( 0, 0, \\omega_1, \\omega_2, \\omega_3 \\), 这里 \\( 2\\omega_i + 1 = 0 \\). 那么 $$ R(f, g) = (-1)^{6 \\times 5} \\times 6^6 \\times p(0) \\times p(0) \\times \\prod_{i = 1}^{3}p(\\omega_i),\r$$ 因为 \\( 2\\omega_i^3 + 1 = 0 \\), 所以 \\( p(\\omega_i) = \\dfrac{3}{4} \\). 因此 \\( R(f, g) = 3^9 \\, 可行的 \\( m \\) 只有 \\( 3 \\). 那么用 \\( 3 \\) 去测试一下. 我们需要找一个 \\( a \\) 让 \\( x \\rightarrow y + a \\) 之后, 可以把三次项消掉. 经过尝试可以取 \\( a = 1 \\). 这样可以说明原多项式不可约.\n","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/posts/eisenstein/","section":"Posts","summary":"","title":"关于 Eisenstein 判别法的笔记","type":"posts"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/tags/%E5%8F%AF%E7%BA%A6/","section":"Tags","summary":"","title":"可约","type":"tags"},{"content":"","date":"2025 年 8 月 5 日","externalUrl":null,"permalink":"/categories/%E6%95%B0%E5%AD%A6/","section":"Categories","summary":"","title":"数学","type":"categories"},{"content":"","date":"2025 年 7 月 31 日","externalUrl":null,"permalink":"/tags/cv%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/","section":"Tags","summary":"","title":"CV(计算机视觉)","type":"tags"},{"content":"","date":"2025 年 7 月 31 日","externalUrl":null,"permalink":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/","section":"Categories","summary":"","title":"计算机","type":"categories"},{"content":"","date":"2025 年 7 月 31 日","externalUrl":null,"permalink":"/tags/%E5%BC%80%E6%94%BE%E9%9B%86%E5%90%88%E7%9B%AE%E6%A0%87%E8%AF%86%E5%88%AB/","section":"Tags","summary":"","title":"开放集合目标识别","type":"tags"},{"content":"\r前言 #\r前些日期我去参加学院组织的暑期实践, 为期一个月. 期间从零开始学习了深度学习和图像识别技术, 最后部署了一下 AAAI'25 接收的一篇论文中的模型 LAE-DINO, 并在 LAE-1M 数据集中的部分图片和实践公司提供的卫星图片上简单测试了. 应该说因为专业不相关, 所以主要时间都花在学习深度学习知识上了, 没有做出什么实质性工作. 不过在使用(准确是说「玩」)这个模型的时候, 我发现了一个奇妙的现象, 因此记录于此.\nLAE-DINO #\rLAE-DINO 模型能检测遥感影像(Remote Sensing)对象, 基于 DINO (或者说应该是 Grounding DINO?) 设计. 其特点是「开放集合目标识别(Open-set Object Detection)」, 即在语言的提示下, 可以识别训练集中没出现的类别. 实际使用中, 我们需要给模型提供一条「提示词」, 把所有希望查询的类别拼成一个字符串, 例如 playground . road . tank . airplane . vehicle.\n模型是如何「认识」未知类别的呢? 简单来说就是通过语言. 人类可以把对象特征分解为几个「通用」特征的组合, 例如「百事 = 红 + 蓝 + 太极」, 这样即便人没见过百事, 如果以及知道后面三个特征, 依然可以从可口和百事中区分并选出百事可乐. 在模型中可能并不存在这么具体的分解过程, 但是语言模型学习到的特征确实有这种「组合」性质(可见 3b1b 的视频). 我对这类开放集合目标识别模型目前的理解就是: 通过交叉注意力机制等方式融合图像和文本特征, 让模型能认识图像更底层的「通用」特征, 这样就能靠描述来识别未知类别了.\n我不是人工智能专业的, 看过的模型也很少, 不太了解一般目标识别模型能达到怎样的水平. 不过在我看来, LAE-DINO 并不是一个出色的模型. 最初我使用官方提供的测试指令\npython demo/image_demo.py images/airplane.jpg \\ configs/lae_dino/lae_dino_swin-t_pretrain_LAE-1M.py \\ --weights /path/to/model/ \\ --texts \u0026#39;playground . road . tank . airplane . vehicle\u0026#39; -c \\ --palette random \\ --pred-score-thr 0.4 在测试集中的一张机场图片上推理(inference), 推理结果上居然一个框都没有! 后面才发现是 0.4 的 pred-score-thr 太高了, 下降一点就好了. 相比之下, 这篇论文更大的价值可能是给出了一个 LAE-1M 数据集. 但其实这个数据集也不是很好. 根据论文的说法, 这个数据集统合了目前的一些开源数据集, 如 DIOR, DOTA v2 等等. 对那些有精细标注的数据, 统一了数据格式; 而对没有精细标注, 只有图片-描述的数据集, 采用 Segment Anything + 语言模型的半自动标注工具, 标注图像中的部分目标. 但这个自动标注还有很大提升空间, 机场里的飞机都不能全部标出来, 质量有点低了. 后面我也看了 SAM 的数据标注过程, 可能目前这个时段, 想要获得高质量的标注, 找高质量的人是不可或缺的. 也正是如此, 感觉个人/小团体研究很难作出比大公司好的成果啊.\n发现 #\r虽然模型的初次使用效果很差, 但是也没有其他模型可用. 而且我手头也没有数据, 也还没有编写模型代码的经验, 不能自己设计. 所以我还是在这个模型上继续测试. 不能改架构, 那么能调整的就只有查询词和阈值了.\n我的第一个想法, 也是很容易想到的想法就是: 用相关的词能否增强查询效果? 在 LAE-DINO 的论文中提到, 他们会提取「场景特征(scene feature)」, 方法是将场景中相关的对象的特征加权平均, 例如 airport \u0026lt;- airplane + vehicle + .... 那么反过来, 如果提供很多同一场景的物品, 是否能激发模型的理解力? 而且 LAE-DINO 提取语言特征(text backbone)用的是 BERT 模型, 其提取语言特征用了 transformer 架构, 而 transformer 中重要的注意力机制就会考虑相邻词汇之间的联系. 所以这两者都启发我们, 用相关的词是可以增强效果的. 因此我尝试用多个近义词(如 car . vehicle . bus)代替单个词(如 vehicle)去查询, 并且避免一次查询多个类别的目标(例如避免官方例子中的那种提示词). 结论是效果确实有提升, 但是提升的不多.\n但随后的测试中, 由于一次拼写错误, 我发现了一个奇异的现象:\nbuilding\r... residential\r... residental\r如上图. 图片来自 LAE-1M 中 AID 数据集的 denseresidential_96.jpg, 阈值固定为 0.2, 从左到右的测试文本分别是 building, building . house . home . residential, building . house . home . residental. 可以看出添加了近义词之后, 检测效果有了明显提升; 而 residental 的效果比 residential 的效果还要好(在阈值相同的情况下, 多检测出了几个楼房). 但是 residental 实际上是错误的拼写, 这就很奇怪了, 为什么错误的拼写比正确的效果还要好呢?\n需要补充的是, 这里的「效果好」是从两个方面体现, 一个是找到的对象数量(召回率), 另一个是模型对检测结果的置信度(在 MMDetection 框架中, 表现为推理后模型给出的分数, 对应准确率). 前者较低, 则对应着「模型」遗漏较多物品; 后者较低, 则说明模型更容易把正确的和错误的混淆. 在检测结果固定时, 为了得到更多正确结果, 我们不得不降低置信度筛选阈值(score_threshold). 而降低阈值, 则找到的对象会变多, 但是代价是更多识别错误也会被保留, 准确度降低; 反过来, 为了提高准确度, 则必须提高阈值. 因此在模型并非完美时, 二者会相互削弱. 而从上三图片可见, residental 实际上是「增大了楼房被检测的分数」, 在这张图上大致增强了 0.05 左右, 而非楼房物品的变化则不明显(至少没有出现新的错误检验). 因此在阈值不变的情况下, 检测到了更多楼房, 这就是同时提高了召回率和准确率.\n随后我又联系 transformer 模型的结构, 想到 transformer 需要先分割语句, 提取分割后单词的特征. 而这些单词并不是按空格分开, 实际上还可能会按词根分开. 所以 residental 里面的 tal 可能是重点. 将提示词中的 residental 替换为 tal 之后, 效果居然一致地好.\nWord Root is all you need!(开个玩笑)\n因此我推测词根可能是这里起作用的关键, 随后我开始测试各种词根的检测效果.\n进一步实验 #\r接下来的测试十分暴力. 我让 DeepSeek 生成了一些英文的前后缀, 随后随机取其中的 6 个, 并与固定的实词结合, 检查推理效果. 随后我发现, 这些词根确实能提高检测效果, 而且不同词根检测物品有不同的倾向. 例如 ment, ness, tion 比较适合检测如楼房般方正的对象, a, ance, let 比较适合检测微小的对象. 最后我简单地通过\n重复上述的随机检测足够多次, 统计检测到的目标数量 取目标数量较多的那些词根组合, 统计词根出现频率 用最高的 6 个词根作为目前的「最优提示词」 三步找到了一个(在单张图片上)效果不错的提示词. 以汽车为例, 实践公司提供的卫星影像里, 汽车基本只有几个像素大小, 因此我也从 LAE-1M 里选择了几个看起来差不多大的图片来演示\nviaduct_48\rviaduct_54\rviaduct_64\rviaduct_48 +\rviaduct_54 +\rviaduct_64 +\r第一行的提示词均为 car . vehicle . bus, 第二行的均为 car . vehicle . bus . a . al . ance . ish . ward, 阈值均为 0.05. 由于使用 MMDetection 自带的绘制 BBox 工具, 汽车会被标签遮挡, 导致完全看不到检测到了什么(, 而且我也不知道怎么修改), 所以我自己绘制了 BBox.\n可以明显看到, 使用了莫名其妙的词根之后, 检测到的车辆大幅增加, 特别在 viaduct_54.jpg 上, 几乎把所有汽车都检测出来了. 我觉得这是很惊人的, 因为实际去看卫星影像里的汽车, 有些人眼都分辨不出来是不是车, 所以在这个问题下模型能保证召回率就很不容易了. 但是在 viaduct_64.jpg 上效果明显不如前一个, 左上的很多汽车都没有被检测到. 在实践期间我测试了整个城区里上述提示词的检测效果, 结果也是如此: 在有些图片上效果极佳, 但是在有些图片上效果极差. 而两个极端的图片又其实没有太大的区别. 因为实践时间较短, 我暂时没有给出更好的方案.\n从结果来看, 我认为用词根增强搜索结果是可行的. 但是要想达到更好的效果, 肯定还需要进一步的研究.\n结论 #\r首先, 关于如何进一步找到更好的检测提示词, 我有一个设想: 由于遥感影像中事物类别较为有限, 所以可以为一些常用类别提前设计好专用的辅助词根. 而对某个特定目标, 可以通过上文中的方法先生成一些「词语-识别准确率+召回率」的关系, 并用这些关系作为数据训练一个(前馈)神经网络, 用模型估计每个词对结果的贡献. 毕竟我使用的数据都是没有标注的, 实际上并不知道检测到的是正确还是错误, 只看检测数量其实就是有缺陷的.\n其次, 这一过程说明了开放集合图像识别在识别任务中的优势. 在模型不变的情况下, 调整输入的自然语言可以显著提高识别效果, 说明开放集合目标识别不仅有机会识别训练集以外的目标, 即使在固定种类的目标识别问题上也能通过语言的微调来增强结果.\n最后, 我认为这种手段未必在所有的 grounding 类开放集目标识别模型上都适用. 首先我只测试了 LAE-DINO 模型, 其次很显然提示词被处理后得到的向量与语言模型和输入方式(这里是用.连接)有关, 同时语言向量和图特征向量的联系也和训练过程有关. 所以更换模型或者更换训练数据, 很可能会导致词根的效果变化. 还有, 英语的词根的地位实际上和汉语的字等同, 从这个角度来看, 如果使用汉语来识别, 可能天然地会比英文有更好的效果. 由于时间有限, 我无法对这个问题给出更多回答了.\n测试代码 #\r如果你对这个事情感兴趣, 我可以提供我用来测试的代码. 模型直接用的是 LAE-DINO Github 中提供的 checkpoint. 测试的代码需要放在 LAE-DINO\\mmdetection_lae 下, 并且同目录下需要一个 config.txt 文件, 提供阈值、是否要用 MMDetection 绘制 BBox、检测图片的目录、提示词等.\ninference.py\nfrom PIL import Image import re import os import json import cv2 import copy import random import seaborn as sns def plot_one_box(x, img, color=None, linewidth=1): # Plots one bounding box on image img tl = linewidth color = color or [random.randint(0, 255) for _ in range(3)] c1, c2 = (int(x[0]), int(x[1])), (int(x[2]), int(x[3])) cv2.rectangle(img, c1, c2, color, thickness=tl, lineType=cv2.LINE_AA) def get_seaborn_colors(n, palette=\u0026#39;husl\u0026#39;): # 可选调色板: \u0026#39;husl\u0026#39;, \u0026#39;Set2\u0026#39;, \u0026#39;dark\u0026#39;, \u0026#39;bright\u0026#39;等 return sns.color_palette(palette, n_colors=n) def inference(input: str, queries: list, thr: float, withlabel=True): from mmdet.apis import DetInferencer init_args = { \u0026#34;model\u0026#34;: \u0026#34;configs/lae_dino/lae_dino_swin-t_pretrain_LAE-1M.py\u0026#34;, \u0026#34;weights\u0026#34;: \u0026#34;checkpoint/lae_dino_swint_lae1m-28ca3a15.pth\u0026#34;, \u0026#34;device\u0026#34;: \u0026#34;cuda:0\u0026#34;, \u0026#34;palette\u0026#34;: \u0026#34;random\u0026#34;, } inferencer = DetInferencer(**init_args) flag_folder = os.path.isdir(input) if flag_folder: output_name = os.path.basename(os.path.normpath(input)) else: filename = os.path.basename(input) output_name, ext = os.path.splitext(filename) print(output_name, ext) inference_args = { \u0026#34;inputs\u0026#34;: input, \u0026#34;texts\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;custom_entities\u0026#34;: True, \u0026#34;pred_score_thr\u0026#34;: thr, \u0026#34;out_dir\u0026#34;: \u0026#34;outputs/\u0026#34; + output_name, \u0026#34;no_save_pred\u0026#34; : False, \u0026#34;no_save_vis\u0026#34; : True, } if withlabel: # use inferencer inference_args[\u0026#34;no_save_vis\u0026#34;] = False else: inference_args[\u0026#34;no_save_vis\u0026#34;] = True texts = [re.sub(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;, line) for line in queries] if flag_folder: raise NotImplementedError # 暂时没写, MMDetection 可以直接推理整个文件夹, 不过似乎不能推理多提示词. 如果只有一个提示词, 那可以直接调用 inferencer else: origin_image = cv2.imread(inference_args[\u0026#34;inputs\u0026#34;]) inference_args[\u0026#34;no_save_vis\u0026#34;] = not withlabel for text in texts: append_name = re.sub(r\u0026#39; \\. \u0026#39;, \u0026#39;+\u0026#39;, text) inference_args[\u0026#34;texts\u0026#34;] = text inferencer(**inference_args) oldname = inference_args[\u0026#34;out_dir\u0026#34;] + \u0026#34;/vis/\u0026#34; + output_name + ext newname = inference_args[\u0026#34;out_dir\u0026#34;] + \u0026#34;/vis/\u0026#34; + output_name + append_name + ext oldnamep = inference_args[\u0026#34;out_dir\u0026#34;] + \u0026#34;/preds/\u0026#34; + output_name + \u0026#34;.json\u0026#34; newnamep = inference_args[\u0026#34;out_dir\u0026#34;] + \u0026#34;/preds/\u0026#34; + output_name + append_name + \u0026#34;.json\u0026#34; if withlabel: if (os.path.exists(newname)): os.remove(newname) if (os.path.exists(newnamep)): os.remove(newnamep) newname = inference_args[\u0026#34;out_dir\u0026#34;] + \u0026#34;/vis/\u0026#34; + output_name + \u0026#34;_label_\u0026#34; + append_name + ext newnamep = inference_args[\u0026#34;out_dir\u0026#34;] + \u0026#34;/preds/\u0026#34; + output_name + \u0026#34;_label_\u0026#34; + append_name + \u0026#34;.json\u0026#34; os.rename(oldname, newname) os.rename(oldnamep, newnamep) else: if (os.path.exists(newname)): os.remove(newname) if (os.path.exists(newnamep)): os.remove(newnamep) colors = get_seaborn_colors(len(text.split(\u0026#39;.\u0026#39;))) os.makedirs(inference_args[\u0026#34;out_dir\u0026#34;] + \u0026#34;/vis\u0026#34;, exist_ok=True) os.rename(oldnamep, newnamep) new_img = copy.copy(origin_image) with open(newnamep, \u0026#39;r\u0026#39;) as jsonfile: args = json.load(jsonfile) labels, scores, bboxes = args.values() for iter in range(0, len(labels)): if (scores[iter] \u0026gt;= thr): bbox = bboxes[iter] color = colors[labels[iter]] plot_one_box(bbox, new_img, color, 1) cv2.imwrite(newname, new_img) del new_img del origin_image def main(): config_name = \u0026#34;./config.txt\u0026#34; # line 1: picture x, y numbers, score_thr # line n: promptss with open(config_name, \u0026#34;r\u0026#34;) as file: commands = file.readlines() _thr, yesno = commands[0].split(\u0026#39; \u0026#39;) thr = float(_thr) if yesno[0] == \u0026#39;T\u0026#39;: withlabel = True else: withlabel = False filename = re.sub(\u0026#39;\\n\u0026#39;, \u0026#39;\u0026#39;, commands[1]) inference(filename, commands[2:], thr, withlabel) if __name__ == \u0026#34;__main__\u0026#34;: main() config.txt example:\n0.05 True \u0026lt;path to img\u0026gt; car car . vehicle . bus . a . al . ance . ish . ward ","date":"2025 年 7 月 31 日","externalUrl":null,"permalink":"/posts/lae-dino-report/","section":"Posts","summary":"","title":"使用语言增强 LAE-DINO 模型检测卫星遥感图像效果 - 初探","type":"posts"},{"content":"","date":"2025 年 7 月 31 日","externalUrl":null,"permalink":"/tags/%E6%8F%90%E7%A4%BA%E8%AF%8Dprompt/","section":"Tags","summary":"","title":"提示词(prompt)","type":"tags"},{"content":"\reXile\n彼女 ","date":"2025 年 7 月 29 日","externalUrl":null,"permalink":"/friends/","section":"Eclipse","summary":"","title":"Friends","type":"page"},{"content":"\r简介 #\r本文记录用 Github Pages + Hugo + Blowfish 搭建博客的重要事项. 大部分内容参考自网络上的博客, 以及 Hugo 和 Blowfish 的官方文档、教程.\n安装环境 #\r我使用的是 Windows 11 系统, 使用 Powershell 7.5.2.\n第一步要安装 Git 和 Hugo. Windows 现在提供了命令行工具 WinGet, 用它来安装软件包非常方便, 特别是可以免去「添加到 PATH」这一步. 和 linux 一样, 安装的指令往往都可以在软件官网直接找到, 例如安装 Git for Windows 的指令是\nwinget install --id Git.Git -e --source winget 安装 Hugo 的指令是\nwinget install Hugo.Hugo.Extended 如此安装后, Hugo 会自动添加到 PATH 里, 所以可以直接用\nhugo version 检查是否安装成功.\n创建本地站点 #\r在 Powershell 中, 输入\nhugo new site \u0026lt;site-name\u0026gt; 可以新建一个 Hugo 项目, 文件结构如下:\n\u0026lt;site-name\u0026gt;\r├─archetypes\r├─assets\r├─content\r├─data\r├─i18n\r├─layouts\r├─static\r└─themes 接下来需要安装主题. 我采用的是 Blowfish 主题, 安装命令是\ncd mywebsite git init -b main git submodule add -b main https://github.com/nunocoracao/blowfish.git themes/blowfish 安装后, Blowfish 主题文件会存放在 theme 文件夹下.\n\u0026lt;site-name\u0026gt;\r├─archetypes\r├─assets\r├─content\r├─data\r├─i18n\r├─layouts\r├─static\r└─themes\r└─blowfish\r├─archetypes\r├─assets\r│ ├─...\r├─config\r│ └─_default\r├─data\r├─exampleSite\r│ ├─...\r├─i18n\r├─images\r├─layouts\r│ ├─...\r├─release-versions\r└─static 其中 exampleSite 是 Blowfish 官网同款网站, 可以用来体验和学习.\n接下来需要把 themes\\blowfish\\config 移动到 \u0026lt;site-name\u0026gt; 目录下, 并删除 \u0026lt;site-name\u0026gt; 目录下原来的 hugo.toml 文件, 用 Blowfish 主题的配置代替默认主题. 然后可以复制 theme\\blowfish\\archetypes 中的文件, 替换 \u0026lt;site-name\u0026gt;\\archetypes 中的文件. 这些 md 文件是模板, 创建新页面时会用到.\n接下来打开 config\\_default\\hugo.toml, 在开头会看到\n# -- Site Configuration -- # Refer to the theme docs for more details about each of these parameters. # https://blowfish.page/docs/getting-started/ # theme = \u0026#34;blowfish\u0026#34; # UNCOMMENT THIS LINE # baseURL = \u0026#34;https://your_domain.com/\u0026#34; defaultContentLanguage = \u0026#34;en\u0026#34; 把 theme = ... 和 baseURL = ... 取消注释. 前者会应用 Blowfish 主题, 后者则是网站的 url, 如果是用 Github Pages, 可以改成对应的 url, 即 https://\u0026lt;github-username\u0026gt;.github.io.\n至此就可以测试网站了, 在 \u0026lt;site-name\u0026gt; 目录下运行\nhugo server 运行后命令行中会显示\n...\rEnvironment: \u0026#34;development\u0026#34;\rServing pages from disk\rRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender\rWeb Server is available at http://localhost:1313/ (bind address 127.0.0.1)\rPress Ctrl+C to stop 用其中给出的 http://localhost:1313/ 即可预览. 按 Ctrl+C 停止预览. 此外, 这个预览会实时更新, 即若改变了本地文件, 网页会自动刷新并更新, 同时, 如果本地文件中出现了错误, 那么预览处也能看到哪里有问题.\n站点配置 #\r待续\n发布 #\rGithub Page 是静态网页托管平台, 所以需要先用 Hugo 生成静态网站, 再推送到 Github 仓库.\n首先在 \u0026lt;site-name\u0026gt; 目录下执行\nhugo 生成静态网站. 其会生成在 \u0026lt;site-name\u0026gt;\\public 文件夹下. 接下来只需要上传此文件夹即可. 即\ncd public git init -b main git remote add origin \u0026lt;your repo.git here\u0026gt; git pull --rebase origin main 从远程仓库拉取, 再\ngit add . 添加本体所有文件. 如果这一步 git 有警告(warning), 提示内容是 ... LF will be replaced by CRLF ..., 则需要特殊处理一下. 具体原理和处理方案可见此处. 简单来说就是 Windows 和 Unix 换行处理不同, 导致某个 SHA256 属性不匹配. 解决方案就是先执行(只需执行一次, 会永久改变)\ngit config --global core.autocrlf false 清理掉之前生成的 public 内容, 重新执行上述 Hugo 和 Git 操作. git add . 之后, 就可以推送到远程了\ngit commit -m \u0026#34;[your comment here]\u0026#34; git push origin main 至此, 可以在 https://\u0026lt;github-username\u0026gt;.github.io 看到博客了(可能需要等几秒钟才会生效). 之后添加了内容之后, 用 Git 推送即可.\n参考资料 #\rHugo Documentation\nBlowfish 中文文档\n如何使用 Github Page 搭建自己的博客\n解决Hugo无法加载css文件\n","date":"2025 年 7 月 29 日","externalUrl":null,"permalink":"/posts/hugo-config/","section":"Posts","summary":"","title":"Hugo + Blowfish 博客配置","type":"posts"},{"content":"写这第一篇文章时，让我想起了一个词：『创刊号』。\n这个词是我在氷菓里面看到的。第一次看到时，我还不知道这个词是什么意思。因为原文说『没有创刊号』，所以我以为创刊号是类似图书 ISBN 序列号的东西。望文生义，就觉得是『创立刊物时获得的编号』。后来，我也忘记有没有特意查过这个词，大概是没有吧，但是我还是明白了这个词的真正含义『刊物的第一期』。因为后面的剧情就是，虽然找到了社刊，但是唯独没有第一期。我想我是看过剧情并理解了这一点之后，明白了创刊号的意思。\n","date":"2025 年 7 月 28 日","externalUrl":null,"permalink":"/posts/my-first-post/","section":"Posts","summary":"","title":"My First Post","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]